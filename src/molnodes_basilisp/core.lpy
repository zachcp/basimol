(ns molnodes_basilisp.core
   (:import bpy
            builtins
            databpy
            mathutils
            [molecularnodes.entities.molecule.molecule :as molecule]
            [molecularnodes.download :as download]
            [molecularnodes.blender.nodes  :as bl_nodes]
            [numpy :as np]
            [biotite.structure.io.pdbx :as pdbx]
            [biotite.structure.filter :as filter]
            [biotite.structure :as struct]
            [biotite.structure.bonds :as bonds])
   (:require [basilisp.string :as str]))

 (defn auto-set-camera []
   #_TODO "auto set the view")

 (defn- center-array [^struct/AtomArray arr]
   (set! (.-coord arr) 
         (np/subtract  (.-coord arr)(databpy/centre (.-coord arr))))
   arr)
   

 ;; Remove Molecules and then the Cube
 (defn clear-objects []
   (let [mol-collection (.. bpy -data -collections (get "Molecular Nodes"))]
     (when mol-collection
       (doseq [obj (.. mol-collection -objects)]
         (.. bpy -data -objects (remove obj ** :do_unlink true))))
     (doseq [obj (.. bpy -data -objects)]
       (when (and (= "MESH" (.-type obj)) (not= "Camera" (.-name obj)))
         (.. bpy -data -objects (remove obj ** :do_unlink true))))))


 ;; styles_mapping = {
;;     "preset_1": "Style Preset 1",
;;     "preset_2": "Style Preset 2",
;;     "preset_3": "Style Preset 3",
;;     "preset_4": "Style Preset 4",
;;     "atoms": "Style Spheres",
;;     "spheres": "Style Spheres",
;;     "vdw": "Style Spheres",
;;     "sphere": "Style Spheres",
;;     "cartoon": "Style Cartoon",
;;     "sticks": "Style Sticks",
;;     "ribbon": "Style Ribbon",
;;     "surface": "Style Surface",
;;     "ball_and_stick": "Style Ball and Stick",
;;     "ball+stick": "Style Ball and Stick",
;;     "oxdna": "MN_oxdna_style_ribbon",
;;     "density_surface": "Style Density Surface",
;;     "density_wire": "Style Density Wire",
;; }
 (def default-styles
   {:cartoon
    {"Selection" true
     "Quality" 2
     "DSSP" true
     "Cylinders" false
     "Arrows" true
     "Rounded" true
     "Thickness" 0.6
     "Width" 2.2
     "Loop Radius" 0.3
     "Smoothing" 0.5
     "Color Blur" false
     "Shade Smooth" false}
    :ball-and-stick
    {"Quality" 2
     "Selection" true
     "Sphere As Mesh" true
     "Sphere Radii" 0.3
     "Bond Split" false
     "Bond Find" false
     "Bond Radius" 0.3
     "Color Blur" false
     "Shade Smooth" false}
    :spheres
    {"Selection" true
     "Sphere As Mesh" true
     "Sphere Radii" 0.8
     "Sphere Subdivisions" 3
     "Shade Smooth" false}
    :surface
    {"Selection" true
     "Quality" 5
     "Separate" false
     "Attribute" "chain_id"
     "Scale Radii" 1.5
     "Probe Size" 1.0
     "Triangulate" false
     "Relaxation Steps" 10
     "Color by CA" false
     "Color Blur" 2
     "Shade Smooth" true}})


 (defn filter-amino-acids [arr] (filter/filter_amino_acids arr))
 
 (defn filter-atomname [arr atomname] (= atomname (.get_annotation arr "atom_name")))
 
 (defn filter-canonical-amino-acids [arr] (filter/filter_canonical_amino_acids arr))
 
 (defn filter-canonical-nucleotides [arr] (filter/filter_canonical_nucleotides arr))
 
 (defn filter-carbohydrates [arr] (filter/filter_carbohydrates arr))
 
 (defn filter-chain [arr chain] (= chain (.get_annotation arr "chain_id")))
 
 (defn filter-element [arr element] (= element (.get_annotation arr "element")))
 
 (defn filter-first-altloc [arr] (filter/filter_first_altloc arr))
 
 (defn filter-hetero [arr] (= true (.get_annotation arr "hetero")))
 
 (defn filter-highest-occupancy-altloc [arr] (filter/filter_highest_occupancy_altloc arr))
 
 (defn filter-inscode [arr inscode] (= inscode (.get_annotation arr "ins_code")))
 
 (defn filter-intersection [arr] (filter/filter_intersection arr))
 
 (defn filter-linear-bond-continuity [arr] (filter/filter_linear_bond_continuity arr))
 
 (defn filter-monoatomic-ions [arr] (filter/filter_monoatomic_ions arr))
 
 (defn filter-nucleotides [arr] (filter/filter_nucleotides arr))
 
 (defn filter-peptide-backbone [arr] (filter/filter_peptide_backbone arr))
 
 (defn filter-phosphate-backbone [arr] (filter/filter_phosphate_backbone arr))
 
 (defn filter-polymer [arr] (filter/filter_polymer arr))
 
 (defn filter-resid [arr num] (= num (.get_annotation arr "res_id")))
 
 (defn filter-resname [arr res_name] (= res_name (.get_annotation arr "res_name")))
 
 (defn filter-solvent [arr] (filter/filter_solvent arr))

 
 (defn- get-temp-context-info []
   (let [win (.. bpy -context -window)
         areas3d (let [areas (.. bpy -context -screen -areas)]
                   (-> (filter #(= (.-type %) "VIEW_3D") areas) first))
         region (let [region (.-regions areas3d)]
                  (-> (filter #(= (.-type %) "WINDOW") region) first))]
     {:window win
      :area areas3d
      :region region}))

 
 (defn get-view []
   (let [ctx (get-temp-context-info)
         area3d (:area ctx)
         camera (.. bpy -context -scene -camera)
         region3d (.. area3d -spaces -active -region_3d)]
     (when (and area3d region3d camera)
       (let [view-matrix (.-view_matrix region3d)
             camera-matrix (.inverted view-matrix)]
         (set! (.-matrix_world camera) camera-matrix)
         (let [mat (.-matrix_world camera)]
           (map vec mat))))))


;; core loading function. used molnodes code + biotite bond connections.
 (defn load-pdb [code]
   ^struct/AtomArray
   (let [arr (-> code download/download pdbx.CIFFile/read pdbx/get_structure seq first) ]
     (set! (.-bonds arr) (bonds/connect_via_residue_names arr))
     (center-array arr)))

 
 (defn render! [^struct/AtomArray arr style material]
   "take a collection of states corresponding to frames and generate an output"
  (let [molname (str (gensym))
        [obj _] (molecule/_create_object  arr ** :name molname :style (name style))]
    (println (str "style: "  (name style) " " style))

       ;; style node is created here ......
    (bl_nodes/create_starting_node_tree obj ** :style (name style))
    (let [modifier (first (filter #(= (.-type %) "NODES") (vec (.-modifiers obj))))
          node-tree (.-node_group modifier)
          nodes (.-nodes node-tree)]
      (when-let [style-node (first (filter #(str/includes? (.-name %) "Style") (vec nodes)))]
        (doseq [input (.-inputs style-node)]
          (when (not= (.-type input) "GEOMETRY")
            (let [input-name (.-name input)]
              (let [styles (get core/default-styles style)]
                (doseq [[key value] styles]
                  (when (= input-name key)
                    (println input " " key " " value "")
                    (builtins/setattr input "default_value" value)))))))

         ;; Set the material in the node's Material input 
        (when-let [material-input (first (filter #(= (.-name %) "Material") (.. style-node -inputs)))]
          (.. obj -data -materials (append material))
          (set! (.-default_value material-input) material))))))
  

 (defn set-view! [matrix]
   (let [mmat (mathutils/Matrix (vec matrix))
         ctx (get-temp-context-info)
         area3d (:area ctx)
         camera (.. bpy -context -scene -camera)
         region3d (.. area3d -spaces -active -region_3d)]
     (when (and area3d region3d camera)
       (set! (.. bpy -context -scene -camera -matrix_world) mmat)
       (set! (.-view_matrix region3d) (.inverted mmat)))))


 (comment
   

  (def fap (load-pdb "1fap")) 
   
 (let [arr  (load-pdb "1fap")
       style :cartoon
       genname (str (gensym))
       material (.. bpy -data -materials (new genname))]
   (set! (.-diffuse_color material) [1 0 0 1])
   (render! arr style material))
   

   (defn create-simple-material [name]
     (let [materials (.. bpy -data -materials)
           material (.new materials name)]
       (python/setattr material "use_nodes" true)
       material))
   
    ;; move the view around and get the view
    ;; the move around and set it back
   (def mat01 (get-view))
   (set-view! (get-view)) 
   
    ;; load a file
   (def fap (load-pdb "1FAP"))

 (set-view! (get-view))
 (clear-objects)

 )

   